<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-Doom Homage — Raycaster</title>
<style>
  html,body { height:100%; margin:0; background:#111; color:#ddd; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game { display:block; margin:0 auto; background:#000; width:100%; height:100vh; }
  #hud { position: absolute; left:16px; bottom:18px; color:#fff; text-shadow:0 1px 0 #000; font-weight:600; }
  #cross { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:rgba(255,255,255,0.8); font-size:26px; pointer-events:none; }
  #help { position:absolute; right:12px; top:12px; color:#ccc; font-size:13px; background:rgba(0,0,0,0.4); padding:8px 10px; border-radius:6px; }
  #minimap { position:absolute; left:12px; top:12px; background:rgba(0,0,0,0.35); padding:8px; border-radius:6px; }
  button { margin-top:8px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">HP: <span id="hp">100</span>  Ammo: <span id="ammo">50</span></div>
<div id="cross">+</div>
<div id="minimap"><canvas id="map" width=160 height=160></canvas></div>
<div id="help">
  WASD to move • Mouse to look • Click to shoot • R to restart<br>
  (This is an original, simplified homage — not the original Doom.)
</div>

<script>
// ========== Configuration ==========
const WIDTH = 1024, HEIGHT = 640;            // default canvas resolution
const FOV = Math.PI/3;                      // field of view (60°)
const MAX_DEPTH = 20;
const MAP = [
  "################",
  "#..............#",
  "#..##...##.....#",
  "#..##...##..#..#",
  "#...........#..#",
  "#..###..###...##",
  "#..#...........#",
  "#..#..##......#",
  "#.....##..E...#",
  "#..........##.#",
  "#..E......##..#",
  "#..............#",
  "################"
];
// '#' wall, '.' empty, 'E' enemy spawn
const TEX = [ "#7a4123", "#5a3a22", "#8b5b3a" ]; // simple wall palette

// ========== Canvas / sizing ==========
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mapCanvas = document.getElementById('map');
const mctx = mapCanvas.getContext('2d');
canvas.width = WIDTH; canvas.height = HEIGHT;
canvas.style.width = "100%"; canvas.style.height = "100vh";

// ========== Player ==========
let player = {
  x: 2.5, y: 2.5,
  dir: 0, // angle in radians
  pitch: 0,
  speed: 0.0,
  hp: 100,
  ammo: 50
};

// ========== Input ==========
const keys = {};
let mouseDeltaX = 0;
let mouseDown = false;
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()] = false);
canvas.addEventListener('mousedown', e=>{ mouseDown=true; shoot(); canvas.requestPointerLock?.(); });
window.addEventListener('mouseup', e=> mouseDown=false);
document.addEventListener('pointerlockchange', ()=>{});
window.addEventListener('mousemove', e=> {
  if (document.pointerLockElement === canvas) {
    player.dir += e.movementX * 0.003;
    player.pitch = Math.max(-0.6, Math.min(0.6, player.pitch + e.movementY * 0.003));
  } else {
    // allow limited mouse look when not locked
    player.dir += e.movementX * 0.001;
  }
});

// ========== Map helpers ==========
function mapGet(x,y){
  if(y<0 || y>=MAP.length || x<0 || x>=MAP[0].length) return '#';
  return MAP[y][x];
}

// ========== Enemies ==========
class Enemy {
  constructor(x,y){
    this.x = x; this.y = y;
    this.hp = 30;
    this.alive = true;
    this.lastHit = 0;
  }
  update(dt){
    if(!this.alive) return;
    const dx = player.x - this.x, dy = player.y - this.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 0.9){
      // move toward player if line-of-sight (simple)
      const nx = this.x + (dx/dist)*dt*1.2;
      const ny = this.y + (dy/dist)*dt*1.2;
      if(mapGet(Math.floor(nx), Math.floor(this.y)) === '.') this.x = nx;
      if(mapGet(Math.floor(this.x), Math.floor(ny)) === '.') this.y = ny;
    } else {
      // attack player
      if(Math.random() < 0.01) {
        player.hp = Math.max(0, player.hp - 5);
      }
    }
    if(this.hp <= 0) { this.alive = false; }
  }
}

// spawn enemies from MAP 'E' positions
const enemies = [];
for(let y=0;y<MAP.length;y++){
  for(let x=0;x<MAP[y].length;x++){
    if(MAP[y][x] === 'E') enemies.push(new Enemy(x+0.5, y+0.5));
  }
}

// ========== Shooting ==========
const bullets = [];
function shoot(){
  if(player.ammo <= 0) return;
  player.ammo--;
  const speed = 12;
  bullets.push({
    x: player.x, y: player.y,
    dx: Math.cos(player.dir)*speed,
    dy: Math.sin(player.dir)*speed,
    life: 0.6
  });
  document.getElementById('ammo').textContent = player.ammo;
}

// ========== Raycaster Rendering ==========
function renderScene(dt){
  // clear
  ctx.fillStyle = '#101010';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // sky + floor
  const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/2);
  skyGrad.addColorStop(0,'#2e6bff'); skyGrad.addColorStop(1,'#143'); // stylized
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle = '#444'; ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);

  // For each vertical stripe
  const w = canvas.width;
  for(let x=0;x<w;x++){
    const cameraX = 2*(x/w)-1;
    const rayDir = player.dir + cameraX * FOV/2;
    let rayX = Math.cos(rayDir), rayY = Math.sin(rayDir);

    // DDA
    let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
    let sideDistX, sideDistY;
    const deltaDistX = Math.abs(1 / rayX);
    const deltaDistY = Math.abs(1 / rayY);
    let stepX, stepY;
    let hit = false, side=0;
    if(rayX < 0){ stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
    if(rayY < 0){ stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

    // walk the grid
    let distance = 0;
    for(let i=0;i<100;i++){
      if(sideDistX < sideDistY){ sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
      if(mapGet(mapX,mapY) === '#'){ hit = true; break; }
    }
    if(!hit) continue;
    // calculate perpendicular wall distance
    if(side === 0) distance = (mapX - player.x + (1-stepX)/2) / rayX;
    else distance = (mapY - player.y + (1-stepY)/2) / rayY;
    if(distance <= 0) continue;
    // simple shading based on distance and side
    const lineHeight = Math.floor(canvas.height / distance);
    const drawStart = Math.max(0, Math.floor((-lineHeight/2) + canvas.height/2));
    const drawEnd = Math.min(canvas.height-1, Math.floor((lineHeight/2) + canvas.height/2));
    const texIdx = (mapX + mapY) % TEX.length;
    let color = TEX[texIdx];
    // darken if side or far
    const shade = Math.max(0.2, 1 - Math.min(1, distance/10));
    ctx.fillStyle = shadeColor(color, shade * (side?0.85:1));
    ctx.fillRect(x, drawStart, 1, drawEnd-drawStart+1);
  }

  // Draw enemies as billboards (simple)
  enemies.forEach(enemy=>{
    if(!enemy.alive) return;
    const dx = enemy.x - player.x, dy = enemy.y - player.y;
    const angToEnemy = Math.atan2(dy,dx);
    let rel = normalizeAngle(angToEnemy - player.dir);
    const dist = Math.hypot(dx,dy);
    if(Math.abs(rel) < FOV/2 && dist > 0.4){
      // is visible — project
      const screenX = Math.tan(rel) / Math.tan(FOV/2) * (canvas.width/2) + (canvas.width/2);
      const size = Math.max(4, Math.floor(canvas.height / dist) * 0.8);
      const sy = Math.floor(canvas.height/2 - size/2 - player.pitch*200);
      // draw simple sprite (circle with face)
      ctx.beginPath();
      ctx.fillStyle = enemy.lastHit > 0 ? '#ff8' : '#9f3';
      ctx.ellipse(screenX, sy + size/2, size/2, size/2, 0, 0, Math.PI*2);
      ctx.fill();
      // health bar
      ctx.fillStyle = '#000'; ctx.fillRect(screenX - size/2, sy - 6, size, 4);
      ctx.fillStyle = '#f33'; ctx.fillRect(screenX - size/2, sy - 6, size * (enemy.hp/30), 4);
    }
  });

  // bullets (as small hitscan markers)
  bullets.forEach(b=>{
    const px = b.x - player.x, py = b.y - player.y;
    const ang = Math.atan2(py,px);
    let rel = normalizeAngle(ang - player.dir);
    const dist = Math.hypot(px,py);
    if(Math.abs(rel) < FOV/2){
      const sx = Math.tan(rel) / Math.tan(FOV/2) * (canvas.width/2) + (canvas.width/2);
      const sy = canvas.height/2;
      ctx.fillStyle = '#ffb'; ctx.fillRect(sx-1, sy-1, 2, 2);
    }
  });

  // HUD health
  document.getElementById('hp').textContent = player.hp;
}

// ========== Utilities ==========
function shadeColor(hex, factor){
  // hex like #rrggbb
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  const nr = Math.floor(r*factor), ng = Math.floor(g*factor), nb = Math.floor(b*factor);
  return `rgb(${nr},${ng},${nb})`;
}
function normalizeAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

// ========== Game Loop ==========
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  update(dt);
  renderScene(dt);
  drawMinimap();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt){
  // movement
  const moveSpeed = 3.2;
  let dx = 0, dy = 0;
  if(keys['w']) { dx += Math.cos(player.dir) * moveSpeed * dt; dy += Math.sin(player.dir) * moveSpeed * dt; }
  if(keys['s']) { dx -= Math.cos(player.dir) * moveSpeed * dt; dy -= Math.sin(player.dir) * moveSpeed * dt; }
  if(keys['a']) { dx += Math.cos(player.dir - Math.PI/2) * moveSpeed * dt; dy += Math.sin(player.dir - Math.PI/2) * moveSpeed * dt; }
  if(keys['d']) { dx += Math.cos(player.dir + Math.PI/2) * moveSpeed * dt; dy += Math.sin(player.dir + Math.PI/2) * moveSpeed * dt; }
  // collision
  tryMove(player.x + dx, player.y + dy);

  if(keys['r']) restart();

  // update enemies
  enemies.forEach(e=>e.update(dt));
  // bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.life -= dt;
    if(b.life <= 0) { bullets.splice(i,1); continue; }
    b.x += b.dx * dt; b.y += b.dy * dt;
    // wall collision
    if(mapGet(Math.floor(b.x), Math.floor(b.y)) === '#'){ bullets.splice(i,1); continue; }
    // hit enemy?
    for(let j=0;j<enemies.length;j++){
      const en = enemies[j];
      if(!en.alive) continue;
      const dd = Math.hypot(en.x - b.x, en.y - b.y);
      if(dd < 0.6){
        en.hp -= 15; en.lastHit = 0.2;
        bullets.splice(i,1); break;
      }
    }
  }
  enemies.forEach(e=>{ if(e.lastHit>0) e.lastHit -= dt; });

  // player death check
  if(player.hp <= 0){ // simple death — restart
    restart();
  }
}

function tryMove(nx, ny){
  // keep inside open tiles only
  const pad = 0.15;
  if(mapGet(Math.floor(nx - pad), Math.floor(player.y - pad)) === '.' &&
     mapGet(Math.floor(nx + pad), Math.floor(player.y + pad)) === '.' &&
     mapGet(Math.floor(nx - pad), Math.floor(player.y + pad)) === '.' &&
     mapGet(Math.floor(nx + pad), Math.floor(player.y - pad)) === '.'){
       player.x = nx; player.y = ny;
  } else {
    // slide along walls attempt
    if(mapGet(Math.floor(nx), Math.floor(player.y)) === '.') player.x = nx;
    if(mapGet(Math.floor(player.x), Math.floor(ny)) === '.') player.y = ny;
  }
}

function restart(){
  player.x = 2.5; player.y = 2.5; player.dir = 0; player.hp = 100; player.ammo = 50;
  bullets.length = 0;
  enemies.forEach((e,i)=>{ e.x = Math.floor(Math.random()*(MAP[0].length-4))+3; e.y = Math.floor(Math.random()*(MAP.length-4))+3; e.hp = 30; e.alive = true; });
  document.getElementById('ammo').textContent = player.ammo;
}

// ========== Minimap ==========
function drawMinimap(){
  const cols = MAP[0].length, rows = MAP.length;
  const cw = mapCanvas.width, ch = mapCanvas.height;
  mctx.fillStyle = 'rgba(0,0,0,0.2)'; mctx.fillRect(0,0,cw,ch);
  const cellW = cw/cols, cellH = ch/rows;
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const c = mapGet(x,y) === '#' ? '#666' : '#111';
      mctx.fillStyle = c; mctx.fillRect(x*cellW, y*cellH, cellW, cellH);
      if(mapGet(x,y) === 'E'){ mctx.fillStyle = '#3a3'; mctx.fillRect(x*cellW+cellW*0.25, y*cellH+cellH*0.25, cellW*0.5, cellH*0.5); }
    }
  }
  // player
  mctx.fillStyle = '#ff5'; mctx.beginPath();
  mctx.arc(player.x*cellW, player.y*cellH, 4, 0, Math.PI*2); mctx.fill();
  // direction line
  mctx.strokeStyle = '#ff5'; mctx.beginPath();
  mctx.moveTo(player.x*cellW, player.y*cellH);
  mctx.lineTo((player.x + Math.cos(player.dir)*0.9)*cellW, (player.y + Math.sin(player.dir)*0.9)*cellH);
  mctx.stroke();
}

// ========== Mouse click to shoot (also support keyboard) ==========
window.addEventListener('keydown', e=>{ if(e.key === ' ') shoot(); });

// ========== Small polish: pointer lock hint ==========
canvas.addEventListener('click', ()=> canvas.requestPointerLock?.());

// End of script
</script>
</body>
</html>
