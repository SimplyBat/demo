<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini-Doom Homage — Raycaster (Walls occlude sprites + HUD)</title>
<style>
  html,body { height:100%; margin:0; background:#0b0b0b; color:#ddd; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #game { display:block; margin:0 auto; background:#000; width:100%; height:100vh; }
  #cross { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); color:rgba(255,255,255,0.85); font-size:26px; pointer-events:none; text-shadow:0 1px 0 #000; }
  #minimap { position:absolute; left:12px; top:12px; background:rgba(0,0,0,0.35); padding:8px; border-radius:8px; }
  #help { position:absolute; right:12px; top:12px; color:#ddd; font-size:13px; background:rgba(0,0,0,0.35); padding:8px 10px; border-radius:8px; }
  /* HUD bottom center */
  #hudbar {
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    bottom:18px;
    background: rgba(0,0,0,0.45);
    padding:10px 14px;
    border-radius:12px;
    display:flex;
    gap:18px;
    align-items:center;
    color:#fff;
    font-weight:700;
    min-width:420px;
    backdrop-filter: blur(4px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }
  .hud-section { display:flex; gap:10px; align-items:center; }
  .hpbox { display:flex; flex-direction:column; gap:6px; font-size:13px; }
  .hp-bar { width:220px; height:14px; background:#2b1b1b; border-radius:8px; overflow:hidden; box-shadow: inset 0 -2px 6px rgba(0,0,0,0.6); }
  .hp-fill { height:100%; width:100%; background: linear-gradient(#ff5a4d,#c32); border-radius:8px 0 0 8px; transition: width 0.12s linear; }
  .stat { background:rgba(255,255,255,0.06); padding:6px 8px; border-radius:8px; font-size:13px; min-width:64px; text-align:center; }
  #weapon { font-size:13px; opacity:0.95; }
  #killText { font-size:13px; color:#ffd; }
  #crosshair { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); font-size:26px; color:rgba(255,255,255,0.9); text-shadow:0 1px 0 #000; pointer-events:none; }
  /* small adaptive for small screens */
  @media (max-width:640px){
    #hudbar { min-width:280px; padding:8px; gap:8px; }
    .hp-bar { width:120px; }
  }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="minimap"><canvas id="map" width=160 height=160></canvas></div>
<div id="help">WASD to move • Mouse to look • Click or SPACE to shoot • R to restart</div>

<div id="hudbar">
  <div class="hud-section hpbox">
    <div style="font-size:13px">HP <span id="hpVal">100</span>%</div>
    <div class="hp-bar"><div id="hpfill" class="hp-fill" style="width:100%"></div></div>
  </div>

  <div class="hud-section">
    <div class="stat">
      <div style="font-size:11px;opacity:0.85">WEAPON</div>
      <div id="weapon">Pistol</div>
    </div>
    <div class="stat">
      <div style="font-size:11px;opacity:0.85">AMMO</div>
      <div id="ammo" style="font-size:16px">50</div>
    </div>
  </div>

  <div class="hud-section" style="margin-left:6px">
    <div class="stat">
      <div style="font-size:11px;opacity:0.85">KILLS</div>
      <div id="kills" style="font-size:16px">0</div>
    </div>
  </div>
</div>

<div id="crosshair">+</div>

<script>
/* ========== CONFIG ========== */
const WIDTH = 1024, HEIGHT = 640;
const FOV = Math.PI/3;
const MAP = [
  "################",
  "#..............#",
  "#..##...##.....#",
  "#..##...##..#..#",
  "#...........#..#",
  "#..###..###...##",
  "#..#...........#",
  "#..#..##......#",
  "#.....##..E...#",
  "#..........##.#",
  "#..E......##..#",
  "#..............#",
  "################"
];
const TEX = [ "#7a4123", "#5a3a22", "#8b5b3a" ];

/* ========== CANVAS & STATE ========== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const mapCanvas = document.getElementById('map');
const mctx = mapCanvas.getContext('2d');
canvas.width = WIDTH; canvas.height = HEIGHT;
canvas.style.width = "100%"; canvas.style.height = "100vh";

let depthBuffer = new Float32Array(canvas.width);

let player = { x:2.5, y:2.5, dir:0, pitch:0, hp:100, ammo:50 };

let kills = 0;
let damageFlash = 0; // 0-1 flash when hit

/* ========== INPUT ========== */
const keys = {};
let mouseDown = false;
window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
canvas.addEventListener('mousedown', e => { mouseDown = true; shoot(); canvas.requestPointerLock?.(); });
window.addEventListener('mouseup', e => mouseDown = false);
document.addEventListener('pointerlockchange', ()=>{});
window.addEventListener('mousemove', e => {
  if (document.pointerLockElement === canvas) {
    player.dir += e.movementX * 0.0035;
    player.pitch = Math.max(-0.6, Math.min(0.6, player.pitch + e.movementY * 0.003));
  } else {
    player.dir += e.movementX * 0.001;
  }
});
window.addEventListener('keydown', e => { if (e.key === ' ') shoot(); });

/* ========== MAP HELPERS ========== */
function mapGet(x,y){
  if (y < 0 || y >= MAP.length || x < 0 || x >= MAP[0].length) return '#';
  return MAP[y][x];
}

/* ========== ENEMIES ==========
   Each enemy is a simple sprite with position, hp, alive flag.
   We'll perform an occlusion test using depthBuffer (per column distances).
*/
class Enemy {
  constructor(x,y){
    this.x = x; this.y = y; this.hp = 30; this.alive = true; this.lastHit = 0;
  }
  update(dt){
    if (!this.alive) return;
    const dx = player.x - this.x, dy = player.y - this.y;
    const dist = Math.hypot(dx,dy);
    if (dist > 0.9){
      // movement toward player if line-of-sight-ish (simple)
      const nx = this.x + (dx/dist)*dt*1.2;
      const ny = this.y + (dy/dist)*dt*1.2;
      if (mapGet(Math.floor(nx), Math.floor(this.y)) === '.') this.x = nx;
      if (mapGet(Math.floor(this.x), Math.floor(ny)) === '.') this.y = ny;
    } else {
      // attack
      if (Math.random() < 0.01) {
        const prev = player.hp;
        player.hp = Math.max(0, player.hp - 5);
        if (player.hp < prev) damageFlash = 0.8;
      }
    }
    if (this.hp <= 0 && this.alive) {
      this.alive = false; kills++; document.getElementById('kills').textContent = kills;
    }
  }
}

/* spawn enemies from 'E' map markers */
const enemies = [];
for (let y=0;y<MAP.length;y++){
  for (let x=0;x<MAP[y].length;x++){
    if (MAP[y][x] === 'E') enemies.push(new Enemy(x+0.5, y+0.5));
  }
}

/* ========== BULLETS ========== */
const bullets = [];
function shoot(){
  if (player.ammo <= 0) return;
  player.ammo--; document.getElementById('ammo').textContent = player.ammo;
  bullets.push({
    x: player.x, y: player.y,
    dx: Math.cos(player.dir)*14,
    dy: Math.sin(player.dir)*14,
    life: 0.6
  });
}

/* ========== RAYCAST + DEPTH BUFFER ==========
   For each vertical stripe we record the perpendicular distance to the wall in depthBuffer.
*/
function renderScene(dt){
  // clear
  ctx.fillStyle = '#0f0f12'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // sky + floor
  const skyGrad = ctx.createLinearGradient(0,0,0,canvas.height/2);
  skyGrad.addColorStop(0,'#2e6bff'); skyGrad.addColorStop(1,'#143');
  ctx.fillStyle = skyGrad; ctx.fillRect(0,0,canvas.width,canvas.height/2);
  ctx.fillStyle = '#424242'; ctx.fillRect(0,canvas.height/2,canvas.width,canvas.height/2);

  const w = canvas.width;
  // reset depth buffer
  for (let i=0;i<w;i++) depthBuffer[i] = Infinity;

  // raycast walls (and fill depthBuffer)
  for (let x=0;x<w;x++){
    const cameraX = 2*(x/w)-1;
    const rayDir = player.dir + cameraX * (FOV/2);
    const rx = Math.cos(rayDir), ry = Math.sin(rayDir);
    let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
    let sideDistX, sideDistY;
    const deltaDistX = Math.abs(1 / rx);
    const deltaDistY = Math.abs(1 / ry);
    let stepX, stepY;
    if (rx < 0){ stepX = -1; sideDistX = (player.x - mapX) * deltaDistX; }
    else { stepX = 1; sideDistX = (mapX + 1.0 - player.x) * deltaDistX; }
    if (ry < 0){ stepY = -1; sideDistY = (player.y - mapY) * deltaDistY; }
    else { stepY = 1; sideDistY = (mapY + 1.0 - player.y) * deltaDistY; }

    let hit = false, side = 0;
    for (let i=0;i<200;i++){
      if (sideDistX < sideDistY){ sideDistX += deltaDistX; mapX += stepX; side = 0; }
      else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
      if (mapGet(mapX,mapY) === '#'){ hit = true; break; }
    }
    if (!hit) continue;

    let perpDist;
    if (side === 0) perpDist = (mapX - player.x + (1 - stepX)/2) / rx;
    else perpDist = (mapY - player.y + (1 - stepY)/2) / ry;
    if (perpDist <= 0) continue;
    depthBuffer[x] = perpDist;

    const lineHeight = Math.floor(canvas.height / perpDist);
    const drawStart = Math.max(0, Math.floor((-lineHeight/2) + canvas.height/2));
    const drawEnd = Math.min(canvas.height-1, Math.floor((lineHeight/2) + canvas.height/2));
    const texIdx = (mapX + mapY) % TEX.length;
    const color = TEX[texIdx];
    const shade = Math.max(0.16, 1 - Math.min(1, perpDist/10));
    ctx.fillStyle = shadeColor(color, shade * (side?0.82:1));
    ctx.fillRect(x, drawStart, 1, drawEnd - drawStart + 1);
  }

  /* ========== SPRITE (ENEMY) RENDERING with occlusion ========== */
  // We'll render sprites only where depthBuffer shows them in front of walls.
  // Also update depthBuffer with sprite distances for correct overlapping between sprites.
  enemies.forEach(enemy => {
    if (!enemy.alive) return;
    const dx = enemy.x - player.x, dy = enemy.y - player.y;
    const angTo = Math.atan2(dy,dx);
    const rel = normalizeAngle(angTo - player.dir);
    const dist = Math.hypot(dx,dy);
    if (Math.abs(rel) < FOV/2 && dist > 0.35){
      const screenX = Math.tan(rel) / Math.tan(FOV/2) * (canvas.width/2) + (canvas.width/2);
      const size = Math.max(8, Math.floor(canvas.height / dist) * 0.8);
      const sy = Math.floor(canvas.height/2 - size/2 - player.pitch*200);
      const leftCol = Math.max(0, Math.floor(screenX - size/2));
      const rightCol = Math.min(canvas.width-1, Math.ceil(screenX + size/2));
      // find a contiguous visible horizontal slice using depthBuffer
      let visStart = -1, visEnd = -1;
      for (let c=leftCol; c<=rightCol; c++){
        if (depthBuffer[c] > dist - 0.25) { visStart = c; break; }
      }
      if (visStart >= 0){
        visEnd = visStart;
        while (visEnd+1 <= rightCol && depthBuffer[visEnd+1] > dist - 0.25) visEnd++;
        // clip to visible columns and draw sprite only inside the clip rectangle
        ctx.save();
        ctx.beginPath();
        ctx.rect(visStart, 0, visEnd - visStart + 1, canvas.height);
        ctx.clip();
        // draw enemy "sprite" (simple circular billboard)
        ctx.beginPath();
        ctx.ellipse(screenX, sy + size/2, size/2, size/2, 0, 0, Math.PI*2);
        ctx.fillStyle = enemy.lastHit > 0 ? '#ffd76b' : '#9fcf6f';
        ctx.fill();
        // health bar above sprite
        ctx.fillStyle = '#000';
        ctx.fillRect(screenX - size/2, sy - 8, size, 5);
        ctx.fillStyle = '#f44';
        ctx.fillRect(screenX - size/2, sy - 8, size * Math.max(0, enemy.hp/30), 5);
        ctx.restore();
        // update depthBuffer for those columns so closer sprites will occlude farther ones
        for (let c = visStart; c <= visEnd; c++) depthBuffer[c] = Math.min(depthBuffer[c], dist);
      }
    }
  });

  /* ========== BULLETS & HUD updates (draw indicators for bullets only if visible) ========== */
  bullets.forEach(b => {
    const px = b.x - player.x, py = b.y - player.y;
    const ang = Math.atan2(py, px);
    const rel = normalizeAngle(ang - player.dir);
    const dist = Math.hypot(px, py);
    if (Math.abs(rel) < FOV/2 && dist > 0.1){
      const sx = Math.tan(rel) / Math.tan(FOV/2) * (canvas.width/2) + (canvas.width/2);
      const sy = canvas.height/2;
      ctx.fillStyle = '#ffebc7'; ctx.fillRect(sx-1, sy-1, 2, 2);
    }
  });

  // damage flash overlay
  if (damageFlash > 0){
    ctx.fillStyle = `rgba(255,48,48,${Math.min(0.6, damageFlash * 0.6)})`;
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }

  // update DOM HUD values
  document.getElementById('hpVal').textContent = Math.max(0, Math.round(player.hp));
  document.getElementById('hpfill').style.width = Math.max(0, Math.min(100, (player.hp/100*100))) + '%';
}

/* ========== UTILITIES ========= */
function shadeColor(hex, factor){
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  const nr = Math.floor(r*factor), ng = Math.floor(g*factor), nb = Math.floor(b*factor);
  return `rgb(${nr},${ng},${nb})`;
}
function normalizeAngle(a){
  while (a > Math.PI) a -= Math.PI*2;
  while (a < -Math.PI) a += Math.PI*2;
  return a;
}

/* ========== GAME LOOP & STATE UPDATE ========= */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  update(dt);
  renderScene(dt);
  drawMinimap();
  // decay flashes and hit timers
  damageFlash = Math.max(0, damageFlash - dt * 1.2);
  enemies.forEach(e => { if (e.lastHit > 0) e.lastHit -= dt; });
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt){
  // movement
  const moveSpeed = 3.4;
  let dx = 0, dy = 0;
  if (keys['w']) { dx += Math.cos(player.dir) * moveSpeed * dt; dy += Math.sin(player.dir) * moveSpeed * dt; }
  if (keys['s']) { dx -= Math.cos(player.dir) * moveSpeed * dt; dy -= Math.sin(player.dir) * moveSpeed * dt; }
  if (keys['a']) { dx += Math.cos(player.dir - Math.PI/2) * moveSpeed * dt; dy += Math.sin(player.dir - Math.PI/2) * moveSpeed * dt; }
  if (keys['d']) { dx += Math.cos(player.dir + Math.PI/2) * moveSpeed * dt; dy += Math.sin(player.dir + Math.PI/2) * moveSpeed * dt; }
  tryMove(player.x + dx, player.y + dy);

  if (keys['r']) restart();

  // update enemies
  enemies.forEach(e => e.update(dt));

  // bullets simulation & collisions (hits enemies and walls)
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.life -= dt;
    if (b.life <= 0) { bullets.splice(i,1); continue; }
    b.x += b.dx * dt; b.y += b.dy * dt;
    if (mapGet(Math.floor(b.x), Math.floor(b.y)) === '#'){ bullets.splice(i,1); continue; }
    // hit enemy?
    for (let j = 0; j < enemies.length; j++){
      const en = enemies[j];
      if (!en.alive) continue;
      const dd = Math.hypot(en.x - b.x, en.y - b.y);
      if (dd < 0.6){
        en.hp -= 15; en.lastHit = 0.18;
        if (en.hp <= 0 && en.alive){ en.alive = false; kills++; document.getElementById('kills').textContent = kills; }
        bullets.splice(i,1); break;
      }
    }
  }

  // death
  if (player.hp <= 0){
    // very simple: instant restart for now
    restart();
  }
}

/* collision helpers */
function tryMove(nx, ny){
  const pad = 0.15;
  if (mapGet(Math.floor(nx - pad), Math.floor(player.y - pad)) === '.' &&
      mapGet(Math.floor(nx + pad), Math.floor(player.y + pad)) === '.' &&
      mapGet(Math.floor(nx - pad), Math.floor(player.y + pad)) === '.' &&
      mapGet(Math.floor(nx + pad), Math.floor(player.y - pad)) === '.'){
        player.x = nx; player.y = ny;
  } else {
    if (mapGet(Math.floor(nx), Math.floor(player.y)) === '.') player.x = nx;
    if (mapGet(Math.floor(player.x), Math.floor(ny)) === '.') player.y = ny;
  }
}

/* restart */
function restart(){
  player.x = 2.5; player.y = 2.5; player.dir = 0; player.hp = 100; player.ammo = 50;
  bullets.length = 0;
  kills = 0; document.getElementById('kills').textContent = 0;
  document.getElementById('ammo').textContent = player.ammo;
  // respawn enemies at random-ish open spots
  enemies.forEach(e => {
    e.x = Math.floor(Math.random()*(MAP[0].length-6))+3 + 0.5;
    e.y = Math.floor(Math.random()*(MAP.length-6))+3 + 0.5;
    e.hp = 30; e.alive = true; e.lastHit = 0;
  });
}

/* ========== MINIMAP ========= */
function drawMinimap(){
  const cols = MAP[0].length, rows = MAP.length;
  const cw = mapCanvas.width, ch = mapCanvas.height;
  mctx.fillStyle = 'rgba(0,0,0,0.22)'; mctx.fillRect(0,0,cw,ch);
  const cellW = cw/cols, cellH = ch/rows;
  for (let y=0;y<rows;y++){
    for (let x=0;x<cols;x++){
      const c = mapGet(x,y) === '#' ? '#666' : '#0d0d0d';
      mctx.fillStyle = c; mctx.fillRect(x*cellW, y*cellH, cellW, cellH);
    }
  }
  // enemies on map: only show alive enemies (small red dot)
  enemies.forEach(e => {
    if (!e.alive) return;
    // show if within 8 tiles for clarity
    const dx = e.x - player.x, dy = e.y - player.y;
    if (Math.hypot(dx,dy) < 9) {
      mctx.fillStyle = '#c33'; mctx.beginPath();
      mctx.arc(e.x*cellW, e.y*cellH, 3, 0, Math.PI*2); mctx.fill();
    }
  });
  // player dot & direction
  mctx.fillStyle = '#ffcc33'; mctx.beginPath();
  mctx.arc(player.x*cellW, player.y*cellH, 4, 0, Math.PI*2); mctx.fill();
  mctx.strokeStyle = '#ffcc33'; mctx.beginPath();
  mctx.moveTo(player.x*cellW, player.y*cellH);
  mctx.lineTo((player.x + Math.cos(player.dir)*0.9)*cellW, (player.y + Math.sin(player.dir)*0.9)*cellH);
  mctx.stroke();
}

/* ========== START (pointer lock on click) ========= */
canvas.addEventListener('click', ()=> canvas.requestPointerLock?.());

</script>
</body>
</html>
