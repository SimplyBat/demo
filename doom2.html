<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini-Doom Enhanced</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
  #hud {
    position: absolute; bottom: 10px; left: 10px; color: #fff;
    font-family: monospace; font-size: 20px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="hud">Health: 100 | Ammo: 50</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let WIDTH = canvas.width = window.innerWidth;
let HEIGHT = canvas.height = window.innerHeight;

const MAP = [
  '111111111111',
  '1E00000000E1',
  '100001110001',
  '100000000001',
  '111111111111'
];
const TILE = 64;
const FOV = Math.PI/3;

let player = { x: 2, y: 2, dir: 0 };

const textures = [];
for (let i = 0; i < 2; i++) {
  const t = document.createElement('canvas');
  t.width = TILE; t.height = TILE;
  const tctx = t.getContext('2d');
  tctx.fillStyle = i===0 ? '#888' : '#555';
  tctx.fillRect(0,0,TILE,TILE);
  textures.push(t);
}

// Depth buffer for wall z-order
let depthBuffer = new Array(WIDTH).fill(Infinity);

// Enemy setup
let enemies = [];
for (let y = 0; y < MAP.length; y++) {
  for (let x = 0; x < MAP[0].length; x++) {
    if (MAP[y][x] === 'E') enemies.push({ x: x + 0.5, y: y + 0.5, frame: 0, animTimer: 0 });
  }
}

// Enemy sprite canvas (4-frame simple red blob)
const enemySprite = document.createElement('canvas');
const ectx = enemySprite.getContext('2d');
enemySprite.width = 64; enemySprite.height = 64*4;
for (let f = 0; f < 4; f++) {
  ectx.fillStyle = '#ff4444';
  ectx.beginPath();
  ectx.arc(32, 32, 24 + Math.sin(f/4 * Math.PI*2)*4, 0, 2*Math.PI);
  ectx.fill();
}

// Raycasting function
function castRays() {
  depthBuffer.fill(Infinity);
  for (let x = 0; x < WIDTH; x++) {
    const rayAngle = (player.dir - FOV/2) + (x/WIDTH)*FOV;
    let dist = 0;
    let hit = false;
    let mapX, mapY;
    const step = 0.05;
    while (!hit && dist < 20) {
      dist += step;
      const testX = player.x + Math.cos(rayAngle)*dist;
      const testY = player.y + Math.sin(rayAngle)*dist;
      mapX = Math.floor(testX);
      mapY = Math.floor(testY);
      if (MAP[mapY][mapX] === '1') hit = true;
    }
    const wallHeight = HEIGHT / dist;
    ctx.drawImage(textures[0], 0, 0, TILE, TILE, x, HEIGHT/2 - wallHeight/2, 1, wallHeight);
    depthBuffer[x] = dist;
  }
}

// Enemy render (after walls, respecting depth)
function renderEnemies() {
  for (const e of enemies) {
    e.animTimer += 0.1;
    e.frame = Math.floor(e.animTimer) % 4;
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    const dist = Math.hypot(dx, dy);
    const ang = Math.atan2(dy, dx) - player.dir;
    if (dist > 0.1 && Math.abs(ang) < FOV/2) {
      const screenX = WIDTH/2 + Math.tan(ang)*WIDTH/(2*Math.tan(FOV/2));
      const size = HEIGHT / dist;
      for (let sx = Math.floor(screenX - size/2); sx < Math.floor(screenX + size/2); sx++) {
        if (sx >= 0 && sx < WIDTH && dist < depthBuffer[sx]) {
          const syStart = Math.floor(HEIGHT/2 - size/2);
          const syEnd = Math.floor(HEIGHT/2 + size/2);
          ctx.drawImage(enemySprite, 0, e.frame*64, 64, 64, sx, syStart, 1, syEnd-syStart);
        }
      }
    }
  }
}

// Simple controls
window.addEventListener('keydown', e => {
  if (e.key==='ArrowLeft') player.dir -= 0.1;
  if (e.key==='ArrowRight') player.dir += 0.1;
  if (e.key==='ArrowUp') { player.x += Math.cos(player.dir)*0.1; player.y += Math.sin(player.dir)*0.1; }
  if (e.key==='ArrowDown') { player.x -= Math.cos(player.dir)*0.1; player.y -= Math.sin(player.dir)*0.1; }
});

function gameLoop() {
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  castRays();
  renderEnemies();
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
