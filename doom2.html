<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini DOOM Clone â€” Animated Enemies</title>
<style>
  body { margin:0; overflow:hidden; background:#000; font-family:sans-serif; }
  canvas { display:block; background:#333; }
  #hud { position:absolute; top:10px; left:10px; color:#fff; font-weight:bold; font-size:20px; }
</style>
</head>
<body>
<div id="hud">Kills: <span id="kills">0</span></div>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE_SIZE = 64;
const ENEMY_TEX_SIZE = 64;
const ENEMY_FRAMES = 4;
let kills = 0;

const map = [
  "############",
  "#..........#",
  "#..##......#",
  "#..........#",
  "#....###...#",
  "#..........#",
  "#..........#",
  "############"
];

function mapGet(x, y) { return map[y] ? map[y][x] : '#'; }

const player = { x:2.5, y:2.5, angle:0 };

function resizeCanvas() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
window.addEventListener('resize', resizeCanvas);

const enemyFrames = [];
function generateEnemyFrames() {
  const tints = ['#c1ff9a','#ffd76b','#b0d8ff'];
  tints.forEach((tint, typeIdx) => {
    enemyFrames[typeIdx] = [];
    for(let f=0;f<ENEMY_FRAMES;f++){
      const c=document.createElement('canvas');c.width=c.height=ENEMY_TEX_SIZE;
      const cx=c.getContext('2d');cx.clearRect(0,0,ENEMY_TEX_SIZE,ENEMY_TEX_SIZE);
      const offsetY=Math.sin((f/ENEMY_FRAMES)*Math.PI*2)*2;
      const grad=cx.createRadialGradient(ENEMY_TEX_SIZE*0.45,ENEMY_TEX_SIZE*0.35+offsetY,4,ENEMY_TEX_SIZE*0.45,ENEMY_TEX_SIZE*0.35+offsetY,ENEMY_TEX_SIZE*0.8);
      grad.addColorStop(0,'#fff');grad.addColorStop(0.05,tint);grad.addColorStop(1,'#222620');
      cx.fillStyle=grad;cx.beginPath();cx.ellipse(ENEMY_TEX_SIZE/2,ENEMY_TEX_SIZE/2.2+offsetY,ENEMY_TEX_SIZE*0.34,ENEMY_TEX_SIZE*0.38,0,0,Math.PI*2);cx.fill();
      cx.fillStyle='#080808';cx.beginPath();cx.ellipse(ENEMY_TEX_SIZE*0.35,ENEMY_TEX_SIZE*0.38+offsetY,6,6,0,0,Math.PI*2);cx.fill();
      cx.beginPath();cx.ellipse(ENEMY_TEX_SIZE*0.62,ENEMY_TEX_SIZE*0.38+offsetY,6,6,0,0,Math.PI*2);cx.fill();
      if(Math.random()<0.15){cx.fillStyle=tint;cx.fillRect(ENEMY_TEX_SIZE*0.35-6,ENEMY_TEX_SIZE*0.38+offsetY-6,12,6);cx.fillRect(ENEMY_TEX_SIZE*0.62-6,ENEMY_TEX_SIZE*0.38+offsetY-6,12,6);}
      cx.fillStyle='#d8d8d8';cx.fillRect(ENEMY_TEX_SIZE*0.4,ENEMY_TEX_SIZE*0.6+offsetY,26,8);
      enemyFrames[typeIdx].push(c);
    }
  });
}
generateEnemyFrames();

class Enemy {
  constructor(x,y){this.x=x;this.y=y;this.hp=30;this.alive=true;this.lastHit=0;this.attackCooldown=0;this.rangedCooldown=0;this.type=Math.floor(Math.random()*enemyFrames.length);this.frame=0;this.frameTime=0;this.tex=enemyFrames[this.type][this.frame];}
  update(dt){
    if(!this.alive)return;
    this.frameTime+=dt;if(this.frameTime>0.15){this.frameTime=0;this.frame=(this.frame+1)%ENEMY_FRAMES;this.tex=enemyFrames[this.type][this.frame];}
    const dx=player.x-this.x,dy=player.y-this.y,dist=Math.hypot(dx,dy);
    const los=true;
    if(los&&dist>0.9){const nx=this.x+(dx/dist)*dt*1.2,ny=this.y+(dy/dist)*dt*1.2;if(mapGet(Math.floor(nx),Math.floor(this.y))=='.')this.x=nx;if(mapGet(Math.floor(this.x),Math.floor(ny))=='.')this.y=ny;}
    if(los){this.attackCooldown-=dt;if(dist<=0.95&&this.attackCooldown<=0){this.attackCooldown=0.85;}}
    if(this.hp<=0&&this.alive){this.alive=false;kills++;document.getElementById('kills').textContent=kills;}
    if(this.lastHit>0)this.lastHit-=dt;
  }
}

const enemies=[new Enemy(5.5,5.5),new Enemy(7.5,2.5)];

function drawMap(){const w=TILE_SIZE,h=TILE_SIZE;for(let y=0;y<map.length;y++){for(let x=0;x<map[y].length;x++){ctx.fillStyle=map[y][x]=='#'?'#888':'#444';ctx.fillRect(x*w,y*h,w,h);}}}

function drawPlayer(){ctx.fillStyle='blue';ctx.beginPath();ctx.arc(player.x*TILE_SIZE,player.y*TILE_SIZE,10,0,Math.PI*2);ctx.fill();}

function drawEnemies(){enemies.forEach(e=>{if(e.alive)ctx.drawImage(e.tex,(e.x-0.5)*TILE_SIZE,(e.y-0.5)*TILE_SIZE,TILE_SIZE,TILE_SIZE);});}

let lastTime=0;
function loop(timestamp){
  const dt=(timestamp-lastTime)/1000;lastTime=timestamp;
  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMap();drawPlayer();
  enemies.forEach(e=>e.update(dt));drawEnemies();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

document.addEventListener('keydown',e=>{
  const speed=0.15;
  if(e.key=='w'){if(mapGet(Math.floor(player.x+Math.cos(player.angle)*speed),Math.floor(player.y))=='.')player.x+=Math.cos(player.angle)*speed;if(mapGet(Math.floor(player.x),Math.floor(player.y+Math.sin(player.angle)*speed))=='.')player.y+=Math.sin(player.angle)*speed;}
  if(e.key=='s'){if(mapGet(Math.floor(player.x-Math.cos(player.angle)*speed),Math.floor(player.y))=='.')player.x-=Math.cos(player.angle)*speed;if(mapGet(Math.floor(player.x),Math.floor(player.y-Math.sin(player.angle)*speed))=='.')player.y-=Math.sin(player.angle)*speed;}
  if(e.key=='a')player.angle-=0.1;if(e.key=='d')player.angle+=0.1;
});
</script>
</body>
</html>
